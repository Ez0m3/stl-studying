template<typename T>
class DoublyLinkedList {
private:
    struct Node {
        T data;
        Node* prev;
        Node* next; 
        
        // æ™®é€šèŠ‚ç‚¹æž„é€ å‡½æ•°
        Node(const T& val, Node* p = nullptr, Node* n = nullptr)
            : data(val), prev(p), next(n) {}
        
        // å“¨å…µèŠ‚ç‚¹æž„é€ å‡½æ•°ï¼ˆä¸å­˜å‚¨æ•°æ®ï¼‰
        Node(Node* p = nullptr, Node* n = nullptr)
            : prev(p), next(n) {}
    };
    
    Node* head_sentinel;  // å¤´å“¨å…µ
    Node* tail_sentinel;  // å°¾å“¨å…µ
    size_t size;
    
public:
    DoublyLinkedList() {
        // åˆ›å»ºä¸¤ä¸ªå“¨å…µèŠ‚ç‚¹
        head_sentinel = new Node(nullptr, nullptr);
        tail_sentinel = new Node(nullptr, nullptr);
        
        // è¿žæŽ¥å®ƒä»¬
        head_sentinel->next = tail_sentinel;
        tail_sentinel->prev = head_sentinel;
        
        size = 0;
    }
    
    ~DoublyLinkedList() {
        clear();
        delete head_sentinel;
        delete tail_sentinel;
    }
    
    // ðŸ”¥ å…³é”®ä¼˜åŠ¿ï¼šæ‰€æœ‰æ’å…¥æ“ä½œé€»è¾‘ç»Ÿä¸€
    void insert_before(Node* pos, const T& value) {
        // posä¸ä¼šæ˜¯nullptrï¼Œå› ä¸ºè‡³å°‘æœ‰ä¸¤ä¸ªå“¨å…µ
        Node* new_node = new Node(value, pos->prev, pos);
        pos->prev->next = new_node;
        pos->prev = new_node;
        size++;
    }
    
    // æ’å…¥å¤´éƒ¨ï¼ˆåœ¨head_sentinelåŽæ’å…¥ï¼‰
    void push_front(const T& value) {
        insert_before(head_sentinel->next, value);
    }
    
    // æ’å…¥å°¾éƒ¨ï¼ˆåœ¨tail_sentinelå‰æ’å…¥ï¼‰
    void push_back(const T& value) {
        insert_before(tail_sentinel, value);
    }
    
    // åˆ é™¤èŠ‚ç‚¹
    void erase(Node* node) {
        // nodeä¸ä¼šæ˜¯å“¨å…µï¼ˆè°ƒç”¨è€…åº”ä¿è¯ï¼‰
        node->prev->next = node->next;
        node->next->prev = node->prev;
        delete node;
        size--;
    }
    
    // æ°¸è¿œéžç©ºï¼ˆè‡³å°‘æœ‰ä¸¤ä¸ªå“¨å…µï¼‰
    bool empty() const { return size == 0; }
    
    // èŽ·å–çœŸå®žæ•°æ®èŠ‚ç‚¹
    Node* front() { 
        return (head_sentinel->next == tail_sentinel) 
               ? nullptr : head_sentinel->next;
    }
    
    Node* back() { 
        return (tail_sentinel->prev == head_sentinel) 
               ? nullptr : tail_sentinel->prev;
    }
};