#include <iostream>
#include <vector>
#include <string>
#include <cassert>
#include <algorithm>

// ============ ä½ çš„BSTç±»å®šä¹‰åœ¨è¿™é‡Œ ============

void test_basic_operations() {
    std::cout << "=== åŸºç¡€æ“ä½œæµ‹è¯• ===\n";
    BST<int> tree;
    
    assert(tree.empty());
    assert(tree.size() == 0);
    assert(!tree.contains(5));
    
    assert(tree.insert(5));
    assert(!tree.empty());
    assert(tree.size() == 1);
    assert(tree.contains(5));
    
    assert(tree.insert(3));
    assert(tree.insert(7));
    assert(tree.size() == 3);
    assert(tree.contains(3));
    assert(tree.contains(7));
    
    assert(!tree.insert(5));
    assert(!tree.insert(3));
    assert(!tree.insert(7));
    assert(tree.size() == 3);
    
    std::cout << "âœ“ åŸºç¡€æ“ä½œæµ‹è¯•é€šè¿‡\n";
}

void test_remove_leaf() {
    std::cout << "\n=== æµ‹è¯•åˆ é™¤å¶å­èŠ‚ç‚¹ ===\n";
    BST<int> tree;
    
    tree.insert(5);
    tree.insert(3);
    tree.insert(7);
    tree.insert(2);
    tree.insert(4);
    tree.insert(6);
    tree.insert(8);
    
    assert(tree.size() == 7);
    
    // åˆ é™¤å¶å­èŠ‚ç‚¹
    assert(tree.remove(2));
    assert(tree.size() == 6);
    assert(!tree.contains(2));
    assert(tree.contains(3));
    assert(tree.contains(4));
    assert(tree.contains(5));
    
    assert(tree.remove(8));
    assert(tree.size() == 5);
    assert(!tree.contains(8));
    
    std::cout << "âœ“ åˆ é™¤å¶å­èŠ‚ç‚¹æµ‹è¯•é€šè¿‡\n";
}

void test_remove_one_child() {
    std::cout << "\n=== æµ‹è¯•åˆ é™¤åªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹çš„èŠ‚ç‚¹ ===\n";
    BST<int> tree;
    
    // æ„å»ºæ ‘:    5
    //          /   \
    //         3     8
    //        /     /
    //       1     6
    //              \
    //               7
    tree.insert(5);
    tree.insert(3);
    tree.insert(8);
    tree.insert(1);
    tree.insert(6);
    tree.insert(7);
    
    assert(tree.size() == 6);
    
    // åˆ é™¤èŠ‚ç‚¹8ï¼ˆæœ‰ä¸€ä¸ªå·¦å­èŠ‚ç‚¹6ï¼‰
    assert(tree.remove(8));
    assert(tree.size() == 5);
    assert(!tree.contains(8));
    assert(tree.contains(6));
    assert(tree.contains(7));
    
    // åˆ é™¤èŠ‚ç‚¹3ï¼ˆæœ‰ä¸€ä¸ªå·¦å­èŠ‚ç‚¹1ï¼‰
    assert(tree.remove(3));
    assert(tree.size() == 4);
    assert(!tree.contains(3));
    assert(tree.contains(1));
    
    std::cout << "âœ“ åˆ é™¤åªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹çš„èŠ‚ç‚¹æµ‹è¯•é€šè¿‡\n";
}

void test_remove_two_children() {
    std::cout << "\n=== æµ‹è¯•åˆ é™¤æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹çš„èŠ‚ç‚¹ ===\n";
    BST<int> tree;
    
    // æ ‡å‡†BSTåˆ é™¤æ¡ˆä¾‹
    //       10
    //      /  \
    //     5    15
    //    / \   / \
    //   3   8 12  18
    //  / \   \    /
    // 1   4   9  17
    tree.insert(10);
    tree.insert(5);
    tree.insert(15);
    tree.insert(3);
    tree.insert(8);
    tree.insert(12);
    tree.insert(18);
    tree.insert(1);
    tree.insert(4);
    tree.insert(9);
    tree.insert(17);
    
    assert(tree.size() == 11);
    
    // åˆ é™¤èŠ‚ç‚¹5ï¼ˆæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œç”¨å·¦å­æ ‘çš„æœ€å¤§å€¼4æ›¿æ¢ï¼‰
    assert(tree.remove(5));
    assert(tree.size() == 10);
    assert(!tree.contains(5));
    
    // éªŒè¯æ ‘ä»ç„¶æ­£ç¡®
    assert(tree.contains(1));
    assert(tree.contains(3));
    assert(tree.contains(4));
    assert(tree.contains(8));
    assert(tree.contains(9));
    assert(tree.contains(10));
    assert(tree.contains(12));
    assert(tree.contains(15));
    assert(tree.contains(17));
    assert(tree.contains(18));
    
    // åˆ é™¤æ ¹èŠ‚ç‚¹10
    assert(tree.remove(10));
    assert(tree.size() == 9);
    assert(!tree.contains(10));
    
    std::cout << "âœ“ åˆ é™¤æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹çš„èŠ‚ç‚¹æµ‹è¯•é€šè¿‡\n";
}

void test_clear_and_reuse() {
    std::cout << "\n=== æµ‹è¯•clear()å’Œé‡ç”¨ ===\n";
    BST<int> tree;
    
    // å¡«å……æ•°æ®
    for (int i = 0; i < 20; ++i) {
        tree.insert(i * 2);  // æ’å…¥å¶æ•°
    }
    assert(tree.size() == 20);
    
    // æ¸…ç©º
    tree.clear();
    assert(tree.empty());
    assert(tree.size() == 0);
    
    // é‡æ–°ä½¿ç”¨
    for (int i = 0; i < 10; ++i) {
        tree.insert(i * 3);  // æ’å…¥3çš„å€æ•°
    }
    assert(tree.size() == 10);
    
    // éªŒè¯æ–°æ•°æ®
    for (int i = 0; i < 10; ++i) {
        assert(tree.contains(i * 3));
    }
    
    std::cout << "âœ“ clear()å’Œé‡ç”¨æµ‹è¯•é€šè¿‡\n";
}

void test_string_bst() {
    std::cout << "\n=== æµ‹è¯•å­—ç¬¦ä¸²BST ===\n";
    BST<std::string> tree;
    
    // å„ç§æ’å…¥æ–¹å¼
    std::string s1 = "apple";
    std::string s2 = "banana";
    std::string s3 = "cherry";
    
    // å·¦å€¼æ’å…¥
    assert(tree.insert(s1));
    assert(tree.contains("apple"));
    
    // ç§»åŠ¨æ’å…¥
    assert(tree.insert(std::move(s2)));
    assert(tree.contains("banana"));
    assert(s2.empty());  // è¢«ç§»åŠ¨äº†
    
    // å­—é¢é‡æ’å…¥
    assert(tree.insert("cherry"));
    assert(tree.contains("cherry"));
    
    // ä¸´æ—¶å¯¹è±¡
    assert(tree.insert(std::string("date")));
    assert(tree.contains("date"));
    
    assert(tree.size() == 4);
    
    // åˆ é™¤æµ‹è¯•
    assert(tree.remove("banana"));
    assert(!tree.contains("banana"));
    assert(tree.size() == 3);
    
    // é‡å¤æ’å…¥
    assert(!tree.insert("apple"));
    assert(tree.size() == 3);
    
    std::cout << "âœ“ å­—ç¬¦ä¸²BSTæµ‹è¯•é€šè¿‡\n";
}

void test_large_scale_random() {
    std::cout << "\n=== å¤§è§„æ¨¡éšæœºæµ‹è¯• ===\n";
    BST<int> tree;
    std::vector<int> numbers;
    
    // ç”Ÿæˆ1000ä¸ªéšæœºæ•°
    for (int i = 0; i < 1000; ++i) {
        numbers.push_back(i);
    }
    
    // éšæœºæ‰“ä¹±
    std::random_shuffle(numbers.begin(), numbers.end());
    
    // æ’å…¥æ‰€æœ‰æ•°å­—
    for (int num : numbers) {
        assert(tree.insert(num));
    }
    assert(tree.size() == 1000);
    
    // éªŒè¯æ‰€æœ‰æ•°å­—éƒ½å­˜åœ¨
    for (int i = 0; i < 1000; ++i) {
        assert(tree.contains(i));
    }
    
    // åˆ é™¤ä¸€åŠçš„æ•°å­—
    for (int i = 0; i < 500; ++i) {
        assert(tree.remove(numbers[i]));
    }
    assert(tree.size() == 500);
    
    // éªŒè¯åˆ é™¤çš„æ­£ç¡®æ€§
    for (int i = 0; i < 500; ++i) {
        assert(!tree.contains(numbers[i]));
    }
    for (int i = 500; i < 1000; ++i) {
        assert(tree.contains(numbers[i]));
    }
    
    // æ¸…ç©º
    tree.clear();
    assert(tree.empty());
    
    std::cout << "âœ“ å¤§è§„æ¨¡éšæœºæµ‹è¯•é€šè¿‡\n";
}

void test_edge_cases() {
    std::cout << "\n=== è¾¹ç•Œæƒ…å†µæµ‹è¯• ===\n";
    
    // æµ‹è¯•1: ç©ºæ ‘æ“ä½œ
    {
        BST<int> tree;
        assert(tree.empty());
        assert(!tree.remove(0));
        tree.clear();  // ç©ºæ ‘clearåº”è¯¥æ²¡é—®é¢˜
        assert(tree.empty());
    }
    
    // æµ‹è¯•2: å•èŠ‚ç‚¹æ ‘
    {
        BST<int> tree;
        tree.insert(42);
        assert(tree.size() == 1);
        assert(tree.remove(42));
        assert(tree.empty());
        assert(!tree.remove(42));  // å†æ¬¡åˆ é™¤åº”è¯¥å¤±è´¥
    }
    
    // æµ‹è¯•3: è¿ç»­æ’å…¥åˆ é™¤
    {
        BST<int> tree;
        for (int i = 0; i < 100; ++i) {
            tree.insert(i);
            assert(tree.contains(i));
            assert(tree.remove(i));
            assert(!tree.contains(i));
            assert(tree.empty());
        }
    }
    
    // æµ‹è¯•4: æ’å…¥å·²åˆ é™¤çš„å€¼
    {
        BST<int> tree;
        tree.insert(100);
        tree.remove(100);
        assert(tree.insert(100));  // åº”è¯¥å¯ä»¥é‡æ–°æ’å…¥
        assert(tree.size() == 1);
    }
    
    std::cout << "âœ“ è¾¹ç•Œæƒ…å†µæµ‹è¯•é€šè¿‡\n";
}

void test_move_semantics_simple() {
    std::cout << "\n=== ç§»åŠ¨è¯­ä¹‰æµ‹è¯• ===\n";
    
    BST<std::string> tree;
    
    // æµ‹è¯•ç§»åŠ¨æ’å…¥
    std::string large_str(1000, 'X');
    tree.insert(std::move(large_str));
    assert(tree.contains(std::string(1000, 'X')));
    assert(large_str.empty());  // ç¡®è®¤è¢«ç§»åŠ¨äº†
    
    // æµ‹è¯•æ‹·è´æ’å…¥
    std::string small_str = "hello";
    tree.insert(small_str);
    assert(tree.contains("hello"));
    assert(!small_str.empty());  // ç¡®è®¤æ²¡æœ‰è¢«ç§»åŠ¨
    
    // æµ‹è¯•å­—é¢é‡å’Œä¸´æ—¶å¯¹è±¡
    tree.insert("world");
    tree.insert(std::string("test"));
    
    assert(tree.size() == 4);
    
    std::cout << "âœ“ ç§»åŠ¨è¯­ä¹‰æµ‹è¯•é€šè¿‡\n";
}

int main() {
    std::cout << "å¼€å§‹æµ‹è¯•BSTå®ç°...\n\n";
    
    try {
        test_basic_operations();
        test_remove_leaf();
        test_remove_one_child();
        test_remove_two_children();
        test_clear_and_reuse();
        test_string_bst();
        test_large_scale_random();
        test_edge_cases();
        test_move_semantics_simple();
        
        std::cout << "\nğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼BSTå®ç°å®Œå…¨æ­£ç¡®ã€‚\n";
        return 0;
    } 
    catch (const std::exception& e) {
        std::cerr << "\nâŒ æµ‹è¯•å¤±è´¥: " << e.what() << "\n";
        return 1;
    }
    catch (const char* msg) {
        std::cerr << "\nâŒ æµ‹è¯•å¤±è´¥: " << msg << "\n";
        return 1;
    }
    catch (...) {
        std::cerr << "\nâŒ æœªçŸ¥æµ‹è¯•é”™è¯¯\n";
        return 1;
    }
}