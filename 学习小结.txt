1.å‘½åè§„èŒƒ

// è…¾è®¯/åä¸º/é˜¿é‡Œé€šç”¨é£æ ¼
class DataProcessor;          // ç±»åï¼šå¤§é©¼å³°
int m_bufferSize;            // æˆå‘˜å˜é‡ï¼šm_å‰ç¼€+å°é©¼å³°
static int s_instanceCount;  // é™æ€æˆå‘˜ï¼šs_å‰ç¼€
void processData();          // å‡½æ•°åï¼šå°é©¼å³°
const int MAX_SIZE = 1024;   // å¸¸é‡ï¼šå…¨å¤§å†™+ä¸‹åˆ’çº¿
int* pBuffer;                // æŒ‡é’ˆï¼špå‰ç¼€ï¼ˆä¼ ç»Ÿé£æ ¼ï¼‰

2. å¤´æ–‡ä»¶è§„èŒƒ

// å­—èŠ‚è·³åŠ¨/è…¾è®¯é£æ ¼
#pragma once                  // é¦–é€‰#pragma once
#ifndef _HEADER_NAME_H_      // æˆ–ä¼ ç»Ÿå®ä¿æŠ¤
#define _HEADER_NAME_H_

#include <vector>
#include <string>
// é¡ºåºï¼šç³»ç»Ÿå¤´æ–‡ä»¶ -> ç¬¬ä¸‰æ–¹åº“ -> é¡¹ç›®å¤´æ–‡ä»¶

namespace company {
namespace module {

class ClassName {
    // å£°æ˜é¡ºåºï¼špublic -> protected -> private
};

} // namespace module
} // namespace company

#endif // _HEADER_NAME_H_

3. ç±»è®¾è®¡è§„èŒƒ

// ç™¾åº¦/é˜¿é‡Œé£æ ¼
class NetworkManager final {  // æ˜ç¡®finalé˜²æ­¢ç»§æ‰¿
public:                       // è®¿é—®é™å®šç¬¦å•ç‹¬ä¸€è¡Œ
    using Ptr = std::shared_ptr<NetworkManager>;
    
    // æ„é€ /ææ„æ”¾æœ€å‰é¢
    explicit NetworkManager(Config config);  // å•å‚æ„é€ å¿…é¡»explicit
    ~NetworkManager() = default;
    
    // åˆ é™¤ä¸éœ€è¦çš„å‡½æ•°
    NetworkManager(const NetworkManager&) = delete;
    NetworkManager& operator=(const NetworkManager&) = delete;
    
    // æˆå‘˜å‡½æ•°æŒ‰åŠŸèƒ½åˆ†ç»„
    // 1. ç”Ÿå‘½å‘¨æœŸç®¡ç†
    bool initialize();
    void cleanup();
    
    // 2. ä¸šåŠ¡æ¥å£
    Result process(Request& request);
    
private:
    // æˆå‘˜å˜é‡æŒ‰ç›¸å…³æ€§åˆ†ç»„
    Config m_config;
    std::vector<Connection> m_connections;
    
    // å†…éƒ¨å·¥å…·å‡½æ•°
    bool validateRequest(const Request& req);
};

1. æ™ºèƒ½æŒ‡é’ˆä½¿ç”¨è§„èŒƒï¼ˆè…¾è®¯/ç½‘æ˜“ï¼‰

// ä¼˜å…ˆä½¿ç”¨unique_ptrï¼Œæ˜ç¡®æ‰€æœ‰æƒ
std::unique_ptr<Resource> resource = std::make_unique<Resource>();

// éœ€è¦å…±äº«æ‰€æœ‰æƒæ—¶æ‰ç”¨shared_ptr
class Manager {
private:
    std::shared_ptr<Cache> m_cache;  // å¤šä¸ªå¯¹è±¡å…±äº«ç¼“å­˜
    
public:
    std::unique_ptr<Task> createTask() {  // å·¥å‚å‡½æ•°è¿”å›unique_ptr
        return std::make_unique<Task>();
    }
};

// ç¦æ­¢ï¼šè£¸æŒ‡é’ˆä½œä¸ºç±»æˆå‘˜ï¼ˆé™¤éæç‰¹æ®Šæƒ…å†µï¼‰
// å¯ä»¥ï¼šå‡½æ•°å‚æ•°ä½¿ç”¨è£¸æŒ‡é’ˆè¡¨ç¤ºå¯é€‰/ä¸å–å¾—æ‰€æœ‰æƒ
void processData(const Data* optionalData = nullptr);

2. å®¹å™¨é€‰æ‹©è§„èŒƒï¼ˆå­—èŠ‚/é˜¿é‡Œï¼‰

// é»˜è®¤é€‰æ‹©
std::vector<T>              // 90%åœºæ™¯çš„é¦–é€‰
std::unordered_map<K, V>    // éœ€è¦å¿«é€ŸæŸ¥æ‰¾æ—¶
std::array<T, N>            // ç¼–è¯‘æœŸå·²çŸ¥å¤§å°

// ç‰¹æ®Šåœºæ™¯
std::deque<T>               // é¢‘ç¹å¤´å°¾æ“ä½œ
std::list<T>                // æå°‘ä½¿ç”¨ï¼Œéœ€è¦è¯æ˜å¿…è¦æ€§
std::map<K, V>              // éœ€è¦æœ‰åºéå†æ—¶

1. å­—ç¬¦ä¸²å¤„ç†ï¼ˆè…¾è®¯æ¸¸æˆï¼‰

// ç¦æ­¢åœ¨å¾ªç¯ä¸­æ‹¼æ¥å­—ç¬¦ä¸²
std::string result;
result.reserve(estimated_size);  // é¢„åˆ†é…å†…å­˜
for (const auto& item : items) {
    result.append(item);
}

// ä½¿ç”¨string_viewé¿å…æ‹·è´
void processString(std::string_view str);  // æ¥å—ä»»æ„å­—ç¬¦ä¸²ç±»å‹

// å°å­—ç¬¦ä¸²ç›´æ¥ä½¿ç”¨charæ•°ç»„
char buffer[64];
snprintf(buffer, sizeof(buffer), "%s_%d", prefix, id);

2. ç§»åŠ¨è¯­ä¹‰è§„èŒƒï¼ˆåä¸ºï¼‰

class DataHolder {
private:
    std::vector<int> m_data;
    
public:
    // æä¾›ç§»åŠ¨æ„é€ å’Œç§»åŠ¨èµ‹å€¼
    DataHolder(DataHolder&& other) noexcept
        : m_data(std::move(other.m_data)) {}
    
    DataHolder& operator=(DataHolder&& other) noexcept {
        if (this != &other) {
            m_data = std::move(other.m_data);
        }
        return *this;
    }
    
    // æ¥å£æ”¯æŒç§»åŠ¨
    void setData(std::vector<int> data) {  // æŒ‰å€¼ä¼ é€’+ç§»åŠ¨
        m_data = std::move(data);
    }
};

3. å†…è”ä¸çƒ­è·¯å¾„ä¼˜åŒ–ï¼ˆé˜¿é‡Œé«˜å¹¶å‘ï¼‰

// é«˜é¢‘è°ƒç”¨çš„å°å‡½æ•°æ ‡è®°ä¸ºinline
inline bool isValid(int value) {
    return value >= 0 && value < MAX_LIMIT;
}

// çƒ­è·¯å¾„é¿å…è™šå‡½æ•°è°ƒç”¨
class Processor {
public:
    virtual void process() = 0;
    
    // æä¾›éè™šæ¥å£ä¾›çƒ­è·¯å¾„è°ƒç”¨
    void fastProcess() {  // å†…è”ã€éè™š
        // ... å¿«é€Ÿå¤„ç†é€»è¾‘
        processImpl();
    }
    
private:
    virtual void processImpl() = 0;  // è™šå‡½æ•°æ”¾private
};

ğŸ”’ å¹¶å‘å®‰å…¨è§„èŒƒ

class ThreadSafeQueue {
private:
    mutable std::mutex m_mutex;  // mutableå…è®¸constæ–¹æ³•åŠ é”
    std::queue<Task> m_queue;
    std::condition_variable m_cv;
    
public:
    void push(Task task) {
        {
            std::lock_guard<std::mutex> lock(m_mutex);  // æœ€å°ä½œç”¨åŸŸ
            m_queue.push(std::move(task));
        }  // lockè‡ªåŠ¨é‡Šæ”¾
        m_cv.notify_one();  // é€šçŸ¥åœ¨é”å¤–è¿›è¡Œ
    }
    
    bool tryPop(Task& task) {
        std::lock_guard<std::mutex> lock(m_mutex);
        if (m_queue.empty()) {
            return false;
        }
        task = std::move(m_queue.front());
        m_queue.pop();
        return true;
    }
};

1. ç›®å½•ç»“æ„ï¼ˆè…¾è®¯/ç™¾åº¦ï¼‰

project/
â”œâ”€â”€ include/                 # å…¬å¼€å¤´æ–‡ä»¶
â”‚   â””â”€â”€ module/
â”‚       â””â”€â”€ public_api.h
â”œâ”€â”€ src/                    # å®ç°æ–‡ä»¶
â”‚   â”œâ”€â”€ module/
â”‚   â”‚   â”œâ”€â”€ internal_impl.cpp
â”‚   â”‚   â””â”€â”€ internal_impl.h  # ç§æœ‰å¤´æ–‡ä»¶æ”¾src
â”‚   â””â”€â”€ main.cpp
â”œâ”€â”€ tests/                  # å•å…ƒæµ‹è¯•
â”‚   â””â”€â”€ module_test.cpp
â”œâ”€â”€ third_party/           # ç¬¬ä¸‰æ–¹åº“
â”œâ”€â”€ build/                 # æ„å»ºè¾“å‡º
â”œâ”€â”€ CMakeLists.txt         # ç°ä»£CMake
â””â”€â”€ README.md

ğŸ“ˆ ä»£ç å®¡æŸ¥é‡ç‚¹
1. å¿…é¡»å®¡æŸ¥é¡¹
å†…å­˜æ³„æ¼å¯èƒ½ï¼ˆæ™ºèƒ½æŒ‡é’ˆä½¿ç”¨æ­£ç¡®æ€§ï¼‰

çº¿ç¨‹å®‰å…¨ï¼ˆç«æ€æ¡ä»¶ã€æ­»é”é£é™©ï¼‰

å¼‚å¸¸å®‰å…¨ï¼ˆèµ„æºæ³„æ¼é£é™©ï¼‰

æ€§èƒ½çƒ­ç‚¹ï¼ˆå¾ªç¯ä¸­çš„é‡å¤è®¡ç®—ã€ä¸å¿…è¦çš„æ‹·è´ï¼‰

ç¼“å†²åŒºæº¢å‡ºé£é™©

2. å¸¸è§ä¸è‰¯æ¨¡å¼ï¼ˆå„å‚é€šç”¨ï¼‰
cpp
// ä¸è‰¯æ¨¡å¼1ï¼šè™šå‡½æ•°è¿‡åº¦ä½¿ç”¨
class Processor {
public:
    virtual ~Processor() = default;
    virtual void step1();
    virtual void step2();  // å¤ªå¤šè™šå‡½æ•°å½±å“æ€§èƒ½
    virtual void step3();
};

// ä¸è‰¯æ¨¡å¼2ï¼šè¿‡åº¦å°è£…
class OverEncapsulated {
private:
    int m_value;
    
public:
    void setValue(int v) { m_value = v; }  // ç®€å•çš„setter/getter
    int getValue() const { return m_value; }  // ç›´æ¥publicæˆå‘˜å¯èƒ½æ›´å¥½
};

// ä¸è‰¯æ¨¡å¼3ï¼šå¼‚å¸¸æ»¥ç”¨
bool loadConfig() {
    if (!file.exists()) {
        throw FileException("not found");  // éå¼‚å¸¸æƒ…å†µä½¿ç”¨å¼‚å¸¸
    }
    return true;
}