==============================
C++ 今日学习总结（数组 / 模板 / swap / 声明语法）
==============================

一、算法学习阶段的代码风格选择
--------------------------------
1. 学算法 ≠ 写 STL
2. 算法学习阶段应优先：
   - 清晰
   - 正确
   - 易理解
3. LeetCode / 业务代码中：
   - 可以直接使用 std::swap
   - 可以直接使用 std::move
   - 不必使用 ADL（using std::swap; swap(...)）

结论：
  算法学习阶段推荐“受控泛型 + std::swap”，
  不必强行写 STL 风格泛型代码。


二、std::swap / ADL / std::move 的核心理解
--------------------------------
1. std::move 只是类型转换，不是“真的移动”
2. swap 的设计目标是：
   - 让类型作者提供更高效、更安全的交换方式
3. ADL 的意义：
   - swap(a,b) 时，编译器会优先查找参数所属命名空间的 swap
4. 写库 / 泛型算法：
   using std::swap;
   swap(a, b);
5. 写业务代码 / 刷题：
   std::swap(a, b);


三、数组作为函数参数的三种情况
--------------------------------
1. T arr[]        → 退化成 T*
2. T* arr         → 指针，没有长度信息
3. T (&arr)[N]    → 数组引用，不退化，保留长度信息

重要结论：
- C 数组永远不会按值传参
- 函数参数里的 T arr[N] 只是“披着数组外衣的指针”


四、T (&arr)[N] 声明语法的真正含义
--------------------------------
T (&arr)[N] 表示：
  arr 是一个引用
  引用的是一个“长度为 N 的 T 类型数组”

关键点：
- & 绑定的是变量名，不是类型
- [] 的优先级高于 &
- 必须用括号改变解析顺序

对比：
- T& arr[N]    ❌ 表示“引用数组”（非法）
- T (&arr)[N]  ✅ 表示“数组的引用”


五、模板参数：类型参数 vs 非类型参数
--------------------------------
模板参数不仅可以是“类型”，也可以是“值”。

示例：
  template<typename T, std::size_t N>

含义：
  T → 类型模板参数
  N → 非类型模板参数（一个编译期常量整数）

N 的来源：
  int arr[7];
  bobblesort(arr);
  ⇒ 编译器自动推导：T=int, N=7

重要区分：
- 模板里的 N 是“类型系统的一部分”
- 函数参数里的 n 才是“算法运行时参数”


六、数组长度 N 不能用来表示“只排前 N 个”
--------------------------------
错误理解：
  sort<int,5>(arr) 表示“只排前 5 个” ❌

真实含义：
  sort<int,5>(arr) 表示“只接受长度正好为 5 的数组”

如果想表达“只处理前 n 个元素”，正确做法：
1. T* arr, size_t n
2. iterator 区间：first, last


七、iterator 与数组的关系
--------------------------------
1. 数组的 iterator 本质上就是指针
2. STL 算法可以直接作用于数组：
   std::begin(arr), std::end(arr)
3. STL 的泛化核心是 iterator，而不是数组或容器本身


八、size_t 与 std::size_t
--------------------------------
1. size_t 是表示“大小 / 数量”的无符号整数类型
2. C++ 标准保证存在的是 std::size_t
3. 推荐在 C++ 中默认使用 std::size_t
4. sizeof / container::size() 返回的都是 std::size_t


九、声明语法的本质理解（最重要）
--------------------------------
C/C++ 的声明本质上是：
  一套“声明运算符”的组合规则

*, &, [], () 都是声明运算符，
它们有固定的优先级和结合顺序。

括号的作用：
  改变解析顺序，让编译器得到我们真正想要的类型

读声明的唯一正确方法：
  从变量名开始，向外读
  遇到括号，先读括号


十、最终心智模型（总结）
--------------------------------
1. 模板像“编译期函数”
   - typename → 类型参数
   - size_t N → 值参数
2. 数组大小是类型的一部分
3. T (&arr)[N] 是唯一能：
   - 不拷贝
   - 不退化
   - 保留长度
   的数组参数写法
4. 接口设计 = 语义设计，不是语法炫技

==============================
