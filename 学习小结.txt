==============================
C++ 学习总结（size_t,std::size_t与int）
==============================

(1) std::size_t 与 size_t 的区别
- std::size_t：C++ 标准保证存在的“表示大小/数量”的无符号整数类型（<cstddef>）。
- size_t：来自C兼容，很多环境会暴露在全局命名空间，但标准上更稳妥的是用 std::size_t。
- 实用建议：在 C++ 中优先写 std::size_t。

(2) std::size_t 与 int 的关系、区别与“下溢”现象
- int：有符号，可表示负数；适合算法计数、反向遍历等需要负数语义的场景。
- std::size_t：无符号，表示大小/下标；不会为负。
- 关键现象：
  std::size_t x = 0; --x;
  x 会回绕成最大值（wrap-around），不是 -1。
  64位常见为 18446744073709551615，32位常见为 4294967295。
- 典型坑：
  for (std::size_t i=n-1; i>=0; --i) 会死循环（i>=0 永远真）。

(3) 工程实践中“int vs size_t”的常见策略（你很喜欢的写法）
- 接口层/容器层：用 std::size_t 对齐标准库（size(), sizeof, 下标语义）。
- 算法层/循环控制：用 int（更直觉，支持 i-- 和 i>=0，避免无符号下溢）。
- 经典模式（折中且常用）：
  std::size_t size = v.size();      // 接口层
  int n = static_cast<int>(size);   // 算法层
  然后 for(int i=0; i<n; ++i) / for(int i=n-1; i>=0; --i)
- 性能问题：
  循环中的这种隐式/显式转换基本不会成为性能瓶颈；
  真正应警惕的是“正确性风险”（有符号/无符号混合比较、下溢），不是速度

(4) Google / LLVM / Linux 对整数类型的真实倾向（工程文化）
- Google（C++）：
  强烈偏向“有符号整数”，谨慎使用无符号；主要原因是无符号下溢/混合比较导致的真实bug太多。
- LLVM/Clang（C++）：
  接口层常用 size_t；算法内部/差值/偏移常用有符号类型（如 ptrdiff_t 或 int），偏折中。
- Linux Kernel（C）：
  更偏向 signed 类型（int/long/ssize_t），强调错误要“显性”，不喜欢无符号回绕的静默行为。