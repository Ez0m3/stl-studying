#include <iostream>

template<typename T>
class LinkedList {
private:
    struct Node {
        T data;
        Node* next;

        // 构造函数
        Node(const T& value) : data(value), next(nullptr) {}
        Node(T&& value) : data(std::move(value)), next(nullptr) {}
    };

    Node* head;  // 链表头指针
    Node* tail;  // 链表尾指针
    size_t size; // 链表中节点的数量

public:
    LinkedList() : head(nullptr), tail(nullptr), size(0) {}

    ~LinkedList() {
        clear();  // 在析构时清空链表
    }

    // 复制构造函数
    LinkedList(const LinkedList& other);

    // 移动构造函数
    LinkedList(LinkedList&& other) noexcept;

    // 复制赋值运算符
    LinkedList& operator=(const LinkedList& other);

    // 移动赋值运算符
    LinkedList& operator=(LinkedList&& other) noexcept;

    // 获取链表大小
    size_t get_size() const { return size; }

    // 检查链表是否为空
    bool is_empty() const { return size == 0; }

    // 清空链表
    void clear();

    // 在链表前插入节点
    void push_front(const T& value);
    void push_front(T&& value);

    // 在链表尾部插入节点
    void push_back(const T& value);
    void push_back(T&& value);

    // 从链表前删除一个节点
    void pop_front();

    // 从链表尾部删除一个节点
    void pop_back();

    // 查找某个值的节点索引
    int find_index(const T& value) const;

    // 打印链表
    void print() const;

    // 反转链表
    void reverse();

private:
    // 帮助函数
    void copy_from(const LinkedList& other); // 拷贝构造和拷贝赋值的帮助函数
    void move_from(LinkedList&& other);     // 移动构造和移动赋值的帮助函数
};

template<typename T>
void LinkedList<T>::push_front(const T& value) {
    Node* new_node = new Node(value);
    if (is_empty()) {
        tail = new_node;
    }
    new_node->next = head;
    head = new_node;
    ++size;
}

template<typename T>
void LinkedList<T>::push_front(T&& value) {
    Node* new_node = new Node(std::move(value));
    if (is_empty()) {
        tail = new_node;
    }
    new_node->next = head;
    head = new_node;
    ++size;
}

template<typename T>
void LinkedList<T>::push_back(const T& value) {
    Node* new_node = new Node(value);
    if (is_empty()) {
        head = new_node;
        tail = new_node;
    } else {
        tail->next = new_node;
        tail = new_node;
    }
    ++size;
}

template<typename T>
void LinkedList<T>::push_back(T&& value) {
    Node* new_node = new Node(std::move(value));
    if (is_empty()) {
        head = new_node;
        ta
